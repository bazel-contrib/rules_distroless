"repository rule for generating a dependency graph from a lockfile."

load(":lockfile.bzl", "lockfile")
load(":starlark_codegen_utils.bzl", "starlark_codegen_utils")
load(":util.bzl", "util")

_ROOT_BUILD_TMPL = """\
"Generated by rules_distroless. DO NOT EDIT."

load("@rules_distroless//apt:defs.bzl", "dpkg_status")
load("@rules_distroless//distroless:defs.bzl", "flatten")

exports_files(['packages.bzl'])

# Map Debian architectures to platform CPUs.
#
# For more info on Debian architectures, see:
#     * https://wiki.debian.org/SupportedArchitectures
#     * https://wiki.debian.org/ArchitectureSpecificsMemo
#     * https://www.debian.org/releases/stable/amd64/ch02s01.en.html#idm186
#
# For more info on Bazel's platforms CPUs see:
#     * https://github.com/bazelbuild/platforms/blob/main/cpu/BUILD
_ARCHITECTURE_MAP = {{
    "amd64": "x86_64",
    "arm64": "arm64",
    "ppc64el": "ppc64le",
    "mips64el": "mips64",
    "s390x": "s390x",
    "i386": "x86_32",
    "armhf": "armv7e-mf",
    "all": "all",
}}

_ARCHITECTURES = {architectures}

[
   config_setting(
    name = os + "_" + arch,
    constraint_values = [
       "@platforms//os:" + os,
       "@platforms//cpu:" + _ARCHITECTURE_MAP[arch],
    ],
  )
  for os in ["linux"]
  for arch in _ARCHITECTURES
]


# List of installed packages. For now it's private.
_PACKAGES = {packages}

# Creates /var/lib/dpkg/status with installed package information.
dpkg_status(
    name = "dpkg_status",
    controls = select({{
        "//:linux_%s" % arch: ["//%s:control" % package for package in packages]
        for arch, packages in _PACKAGES.items()
    }}) if _PACKAGES else {{}},
    visibility = ["//visibility:public"],
)

filegroup(
    name = "packages",
    srcs = select({{
        "//:linux_%s" % arch: ["//%s" % package for package in packages]
        for arch, packages in _PACKAGES.items()
    }}) if _PACKAGES else {{}},
    visibility = ["//visibility:public"],
)


# A filegroup that contains all the packages and the dpkg status file.
filegroup(
    name = "{target_name}",
    srcs = [
        ":dpkg_status",
        ":packages",
    ],
    visibility = ["//visibility:public"],
)

flatten(
    name = "flat",
    tars = [
        "{target_name}",
    ],
    deduplicate = True,
    visibility = ["//visibility:public"],
)
"""

_PACKAGE_TEMPLATE = '''\
"""Generated by rules_distroless. DO NOT EDIT."""

NO_MATCH_ERROR="""
Package "{target_name}" is not available for the current target platform.

Available Platforms: {available_platforms}

- Set `--platforms` on the command line.
- Perform a transition to one of the available platforms
"""

alias(
    name = "data",
    actual = select({data_targets}, no_match_error = NO_MATCH_ERROR),
    visibility = ["//visibility:public"],
)

alias(
    name = "control",
    actual = select({control_targets}, no_match_error = NO_MATCH_ERROR),
    visibility = ["//visibility:public"],
)

filegroup(
    name = "{target_name}",
    srcs = select({deps}, no_match_error = NO_MATCH_ERROR) + [":data"],
    visibility = ["//visibility:public"],
)

{extra}
'''

_DEB_CC_IMPORT = """
alias(
    name = "{target_name}",
    actual =  select({selects}),
    visibility = ["//visibility:public"],
)
"""

def _translate_dependency_set_impl(rctx):
    package_template = rctx.read(rctx.attr.package_template)
    lockf = lockfile.from_json(rctx, rctx.attr.lock_content)

    sources = lockf.sources()
    packages = lockf.packages()
    dependency_sets = lockf.dependency_sets()
    dependency_set = dependency_sets[rctx.attr.depset_name]

    packages_to_architectures = {}

    for architecture in dependency_set["sets"].keys():
        for (short_key, version) in dependency_set["sets"][architecture].items():
            package_key = short_key + "=" + version
            repo_name = util.sanitize(package_key)
            package = packages[package_key]

            packages_to_architectures.setdefault(
                package["name"] + "=" + version,
                struct(
                    name = package["name"],
                    architectures = {},
                ),
            ).architectures[architecture] = package_key

            rctx.file(
                "%s/%s/BUILD.bazel" % (package["name"], architecture),
                package_template.format(
                    target_name = architecture,
                    data_targets = '"@%s//:data"' % repo_name,
                    control_targets = '"@%s//:control"' % repo_name,
                    src = '"@%s//:data"' % repo_name,
                    deps = ["@" + util.sanitize(dep_key) for dep_key in package["depends_on"]],
                    urls = [
                        uri + "/" + package["filename"]
                        for uri in sources[package["suite"]]["uris"]
                    ],
                    name = package["name"],
                    arch = package["architecture"],
                    sha256 = package["sha256"],
                    repo_name = repo_name,
                ),
            )

    for (_, info) in packages_to_architectures.items():
        package_name = info.name

        architectures = info.architectures.keys()

        extra = ""
        if package_name.endswith("-dev"):
            target_name = package_name.removesuffix("-dev")
            extra = _DEB_CC_IMPORT.format(
                target_name = target_name,
                selects = starlark_codegen_utils.to_dict_attr({
                    "//:linux_%s" % architecture: "@%s//:%s" % (util.sanitize(package_key), target_name)
                    for (architecture, package_key) in info.architectures.items()
                }),
            )

        rctx.file(
            "%s/BUILD.bazel" % package_name,
            _PACKAGE_TEMPLATE.format(
                target_name = package_name,
                data_targets = starlark_codegen_utils.to_dict_attr({
                    "//:linux_%s" % architecture: "//%s/%s:data" % (package_name, architecture)
                    for architecture in architectures
                }),
                control_targets = starlark_codegen_utils.to_dict_attr({
                    "//:linux_%s" % architecture: "//%s/%s:control" % (package_name, architecture)
                    for architecture in architectures
                }),
                deps = starlark_codegen_utils.to_dict_list_attr({
                    "//:linux_%s" % architecture: ["//%s/%s" % (package_name, architecture)]
                    for architecture in architectures
                }),
                extra = extra,
                available_platforms = " ".join([
                    "linux/" + arch
                    for arch in architectures
                ]),
            ),
        )

    rctx.file("BUILD.bazel", _ROOT_BUILD_TMPL.format(
        target_name = util.get_repo_name(rctx.attr.name),
        packages = starlark_codegen_utils.to_dict_list_attr({}),
        architectures = starlark_codegen_utils.to_list_attr(dependency_set["sets"].keys()),
    ))

translate_dependency_set = repository_rule(
    implementation = _translate_dependency_set_impl,
    attrs = {
        "depset_name": attr.string(doc = "INTERNAL: DO NOT USE"),
        "lock_content": attr.string(doc = "INTERNAL: DO NOT USE"),
        "package_template": attr.label(default = "//apt/private:package.BUILD.tmpl"),
    },
)
